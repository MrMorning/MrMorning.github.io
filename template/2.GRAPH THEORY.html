<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mrmorning.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="GRAPHIC2.图论2.1图的连通性2.1.1 双连通分量 定理: 在无向连通图G的DFS树中, 非根节点u是G的割顶当且仅当u存在一個子节点v, 使得v及其后代都没有反向边连回u的祖先.  设low(u)为u及其后代所能连回的最早的祖先的pre值, 则定理中的条件就是: 节点u存在一个子节点v, 使得low(v) &gt;&#x3D; pre(u).  对于一个连通图, 如果任意两点存在至少两条”点不重">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen Geng&#39;s Blog">
<meta property="og:url" content="mrmorning.github.io/template/2.GRAPH%20THEORY.html">
<meta property="og:site_name" content="Chen Geng&#39;s Blog">
<meta property="og:description" content="GRAPHIC2.图论2.1图的连通性2.1.1 双连通分量 定理: 在无向连通图G的DFS树中, 非根节点u是G的割顶当且仅当u存在一個子节点v, 使得v及其后代都没有反向边连回u的祖先.  设low(u)为u及其后代所能连回的最早的祖先的pre值, 则定理中的条件就是: 节点u存在一个子节点v, 使得low(v) &gt;&#x3D; pre(u).  对于一个连通图, 如果任意两点存在至少两条”点不重">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/890886/201703/890886-20170319160907276-1392853298.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/890886/201702/890886-20170221114022898-331956418.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/890886/201703/890886-20170319162546573-925706265.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/890886/201703/890886-20170307142821172-459702442.png">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/4931496bfad0e20365b93a0f2c8d996d3b385e0c">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/759601e482258ff7a359a7db381abf60372c5b06">
<meta property="article:published_time" content="2020-08-02T09:03:59.753Z">
<meta property="article:modified_time" content="2020-08-02T09:03:59.753Z">
<meta property="article:author" content="Chen Geng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/890886/201703/890886-20170319160907276-1392853298.png">

<link rel="canonical" href="mrmorning.github.io/template/2.GRAPH%20THEORY">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title> | Chen Geng's Blog
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chen Geng's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="en">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <h1 id="GRAPHIC"><a href="#GRAPHIC" class="headerlink" title="GRAPHIC"></a>GRAPHIC</h1><h2 id="2-图论"><a href="#2-图论" class="headerlink" title="2.图论"></a>2.图论</h2><h3 id="2-1图的连通性"><a href="#2-1图的连通性" class="headerlink" title="2.1图的连通性"></a>2.1图的连通性</h3><h4 id="2-1-1-双连通分量"><a href="#2-1-1-双连通分量" class="headerlink" title="2.1.1 双连通分量"></a>2.1.1 双连通分量</h4><ul>
<li>定理: 在无向连通图G的DFS树中, 非根节点u是G的割顶当且仅当u存在一個子节点v, 使得v及其后代都没有反向边连回u的祖先. </li>
<li>设low(u)为u及其后代所能连回的最早的祖先的pre值, 则定理中的条件就是:</li>
<li>节点u存在一个子节点v, 使得low(v) &gt;= pre(u). </li>
<li>对于一个连通图, 如果任意两点存在至少两条”点不重复”的路径, 就说这个图是点-双连通的, 这个要求等价于任意两条边都在同一个简单环中, 即内部无割顶. 类似的定义边-双连通. 对于一张无向图, 点-双连通的<em>极大</em>子图称为双连通分量. </li>
<li>不同双连通分量最多只有一个公共点, 且它一定是割顶. 任意割顶都是两个不同双连通分量的公共点.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;Edge&gt; S;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lowu = pre[u] = ++dfs_clock;</span><br><span class="line">  <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">    Edge e = (Edge)&#123;u, v&#125;;</span><br><span class="line">    <span class="keyword">if</span>(!pre[v]) &#123;</span><br><span class="line">      S.push(e);</span><br><span class="line">      child++;</span><br><span class="line">      <span class="keyword">int</span> lowv = dfs(v, u);</span><br><span class="line">      lowu = <span class="built_in">min</span>(lowu, lowv);</span><br><span class="line">      <span class="keyword">if</span>(lowv &gt;= pre[u]) &#123;</span><br><span class="line">        iscut[u] = <span class="literal">true</span>;</span><br><span class="line">        bcc_cnt++;</span><br><span class="line">        bcc[bcc_cnt].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">          Edge x = S.top(); S.pop();</span><br><span class="line">          <span class="keyword">if</span>(bccno[x.u] != bcc_cnt) &#123;bcc[bcc_cnt].push_back(x.u); bccno[x.u] = bcc_cnt;&#125;</span><br><span class="line">          <span class="keyword">if</span>(bccno[x.v] != bcc_cnt) &#123;bcc[bcc_cnt].push_back(x.v); bccno[x.v] = bcc_cnt;&#125;</span><br><span class="line">          <span class="keyword">if</span>(x.u == u &amp;&amp; x.v == v) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pre[v] &lt; pre[u] &amp;&amp; v != fa) &#123;</span><br><span class="line">      S.push(e);</span><br><span class="line">      lowu = <span class="built_in">min</span>(lowu, pre[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fa &lt; <span class="number">0</span> &amp;&amp; child == <span class="number">1</span>) iscut[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> lowu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>边-双连通分量可以使用更简单的方法求出, 分两个步骤, 先做一次dfs标记出所有的桥, 然后再做一次dfs找出边-双连通分量. 因为边-双连通分量是没有公共节点的, 所以只要在第二次dfs的时候保证不经过桥即可.</li>
</ul>
<h4 id="2-1-2-强连通分量"><a href="#2-1-2-强连通分量" class="headerlink" title="2.1.2 强连通分量"></a>2.1.2 强连通分量</h4><p>kosaraju算法.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  vis[v] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[G[v][i]])</span><br><span class="line">      dfs(G[v][i]);</span><br><span class="line">  &#125;</span><br><span class="line">  vs.push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  vis[v] = <span class="literal">true</span>;</span><br><span class="line">  cnt[v] = k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rG[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[rG[v][i]])</span><br><span class="line">      rdfs(rG[v][i], k);</span><br><span class="line">  &#125;</span><br><span class="line">  vs.push_back(v);</span><br><span class="line">  sc[k].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  vs.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[v])</span><br><span class="line">      dfs(v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = vs.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[vs[i]]) &#123;</span><br><span class="line">      rdfs(vs[i], k++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-2-SAT"><a href="#2-1-3-2-SAT" class="headerlink" title="2.1.3 2-SAT"></a>2.1.3 2-SAT</h4><p>给定一个布尔方程, 判断是否存在一组布尔变量的真值指派似的整个方程为真, 这种问题被称为$\mathfrak{SAT}$问题. 如果合取范式的每个子句中的文字个数都不超过两个, 那么这种问题被称为$\mathfrak{2-SAT}$问题.</p>
<p>求解$2-SAT$问题的一般方式是:</p>
<ol>
<li><p>首先, 利用$\Rightarrow$(蕴含)把每个子句($a\vee b$)改写成等价形式$(\neg a\Rightarrow b \wedge \neg b \Rightarrow a)$. 这样原来的布尔方程就变成了$a \Rightarrow b$形式的布尔公式用$\wedge$链接起来的形式.</p>
</li>
<li><p>对于每个布尔变量$x$, 构造两个顶点分别表示$x$和$\neg x$, 以$\Rightarrow$关系为有向边建立有向图. 此时, 如果$a$能够到达$b$, 那么$a$和$b$的真值一定是相同的, 因此, 该图中同一个强连通分量所含的所有文字的真值相同.</p>
</li>
<li><p>如果存在每个变量$x$使得$x$和$\neg x$在同一个强连通分量中, 那么不合法, 反之, 对于每个变量, 构造性地令</p>
<p>​                $x$所在的强连通分量拓扑序在$\neg x$所在的强连通分量之后$\Leftrightarrow$$x$为真</p>
<p>就是一种布尔变量赋值.</p>
</li>
</ol>
<h3 id="2-2-最短路与最小生成树"><a href="#2-2-最短路与最小生成树" class="headerlink" title="2.2 最短路与最小生成树"></a>2.2 最短路与最小生成树</h3><h4 id="2-2-1-SPFA"><a href="#2-2-1-SPFA" class="headerlink" title="2.2.1 SPFA"></a>2.2.1 SPFA</h4><p>虽然是NOIp(<del>professional</del>)知识, 但是由于在省选中非常常用, 还是写一下.</p>
<p>最短路算法也会在分层图中考察.</p>
<p>spfa也可以运用在DP中的转移.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">  dist[s][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;state&gt; q;</span><br><span class="line">  q.push((state)&#123;s, <span class="number">0</span>&#125;);</span><br><span class="line">  <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">  inq[s][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    state u = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    inq[u.pos][u.k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u.pos].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      edge &amp;e = G[u.pos][i];</span><br><span class="line">      <span class="keyword">if</span> (dist[e.to][u.k] &gt; dist[u.pos][u.k] + e.value) &#123;</span><br><span class="line">        dist[e.to][u.k] = dist[u.pos][u.k] + e.value;</span><br><span class="line">        <span class="keyword">if</span> (!inq[e.to][u.k]) &#123;</span><br><span class="line">          q.push((state)&#123;e.to, u.k&#125;);</span><br><span class="line">          inq[e.to][u.k] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (u.k &lt; k &amp;&amp; dist[e.to][u.k + <span class="number">1</span>] &gt; dist[u.pos][u.k]) &#123;</span><br><span class="line">        dist[e.to][u.k + <span class="number">1</span>] = dist[u.pos][u.k];</span><br><span class="line">        <span class="keyword">if</span> (!inq[e.to][u.k + <span class="number">1</span>]) &#123;</span><br><span class="line">          q.push((state)&#123;e.to, u.k + <span class="number">1</span>&#125;);</span><br><span class="line">          inq[e.to][u.k + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spfa可以用来判负环. 所谓负环就是环上边权和为负的环. 一般使用dfs版本spfa判负环.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dist[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  vis[x] = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rg[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    edge &amp;e = rg[x][i];</span><br><span class="line">    <span class="keyword">if</span> (dist[e.to] &gt; dist[x] + e.value)</span><br><span class="line">      <span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dist[e.to] = dist[x] + e.value;</span><br><span class="line">        spfa(e.to);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[x] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> lambda)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    rg[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">      rg[i].push_back((edge)&#123;G[i][j].to, (<span class="keyword">double</span>)G[i][j].value - lambda&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">1</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">  flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    spfa(i);</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spfa还可以用来构造差分约束系统.</p>
<p>所谓差分约束系统是指一个不等式组, 每个不等式形如$x_j-x_i\leqslant b_k$, 这里的$b_k$是一些已经知道的常数. 注意到, 这个不等式类似于最短路中的不等式$d_v \leqslant d_u + w_{u,v}$, 我们可以用最短路算法求解: 对于约束条件$x_j-x_i\leqslant b_k$, 新建一条边$i \rightarrow j$, 权值为$b_k$, 再加一个源点$s$, 从$s$出发与其他所有点相连, 权值为$0$. 在这个图上跑$spfa$算法, 则源点$s$到每一个点$i$的距离就是$x_i$的值. 如果$spfa$失败, 说明存在负圈, 差分约束系统无解.</p>
<h4 id="2-2-2-动态最小生成树"><a href="#2-2-2-动态最小生成树" class="headerlink" title="2.2.2 动态最小生成树"></a>2.2.2 动态最小生成树</h4><p>最小生成树算是很常见的考点.</p>
<p>关于最小生成树, 我们有以下结论:</p>
<ul>
<li><p>对于连通图中的任意一个环 C ：如果C中有边e的权值大于该环中任意一个其它的边的权值，那么这个边不会是最小生成树中的边.</p>
</li>
<li><p>在一幅连通加权无向图中，给定任意的切分，它的横切边中权值最小的边必然属于图的最小生成树。</p>
</li>
<li><p>如果图的具有最小权值的边只有一条，那么这条边包含在任意一个最小生成树中。</p>
</li>
<li><p>次小生成树: 树上倍增+lca</p>
</li>
<li><p>两个点之间的最大权最小路径一定在最小生成森林上(水管局长)</p>
</li>
<li><p>欧几里德最小生成树<br>动态最小生成树: 使用Link-Cut Tree维护.</p>
</li>
<li><p>矩阵树定理(Matrix-Tree)</p>
<blockquote>
<p>下面我们介绍一种新的方法——Matrix-Tree定理(Kirchhoff矩阵-树定理)。Matrix-Tree定理是解决生成树计数问题最有力的武器之一。它首先于1847年被Kirchhoff证明。在介绍定理之前，我们首先明确几个概念：<br>1、G的度数矩阵$D[G]$是一个$n \times n$的矩阵，并且满足：当$i\not = j$时,$d_{ij}=0$；当$i=j$时，$d_{ij}$等于$v_i$的度数。<br>2、G的邻接矩阵$A[G]$也是一个$n \times n$的矩阵， 并且满足：如果$v_i$、$v_j$之间有边直接相连，则$a_{ij}$=1，否则为0。<br>我们定义$G$的<em>Kirchhoff矩阵</em>(也称为拉普拉斯算子)C[G]为C[G]=D[G]-A[G]，则Matrix-Tree定理可以描述为：G的所有不同的生成树的个数等于其Kirchhoff矩阵C[G]任何一个n-1阶主子式的行列式的绝对值。所谓n-1阶主子式，就是对于r(1≤r≤n)，将C[G]的第r行、第r列同时去掉后得到的新矩阵，用Cr[G]表示。</p>
</blockquote>
</li>
<li><p>kruskal 算法: 贪心地选取每一条边</p>
</li>
</ul>
<h3 id="2-3网络流"><a href="#2-3网络流" class="headerlink" title="2.3网络流"></a>2.3网络流</h3><h4 id="2-3-1-预备知识"><a href="#2-3-1-预备知识" class="headerlink" title="2.3.1 预备知识"></a>2.3.1 预备知识</h4><ul>
<li>流网络$G=(V,E)$是一个<strong>有向图</strong>, 其中每条边$&lt;u, v&gt; \in E$均为有一非负容量$c(u, v) \geqslant 0$, 规定: 若$&lt;u,v&gt; \not \in E$, 则$c(u,v)=0$. 网络中有两个特殊点$s$和$t$.</li>
<li>网络的流是一个实值函数$f$:$V \times V \rightarrow R$, 且满足三个性质: 容量限制, 反对称性, 流守恒性.</li>
<li>最大的流是指该网络中流值最大的流.</li>
<li>残留网络由可以容纳更多流的边构成.</li>
<li>增广路径$p$为残留网络上$s$到$t$的一条简单路径.</li>
<li>流网络$G=(V, E)$的割$[S, T]$将点集划分为$S$和$T$两部分, 使得$s \in S\ and\ t \in T$. 符号$[S, T]={&lt;u,v&gt;|&lt;u,v&gt; \in E, u \in S, v \in T}$, 通过割的净流为$f(S,T)$, 容量定义为$c(S,T)$.</li>
<li>一个网络的最小割就是网络中容量最小的割.</li>
</ul>
<h4 id="2-3-2-最大流最小割定理与线性规划"><a href="#2-3-2-最大流最小割定理与线性规划" class="headerlink" title="2.3.2 最大流最小割定理与线性规划"></a>2.3.2 最大流最小割定理与线性规划</h4><p>首先我们假设读者已经有了线性规划的基本知识.</p>
<p>最大流问题的线性规划描述:<br>$$<br>\begin{alignat}{2}</p>
<p>\max\quad &amp;f_{ts} &amp;{}&amp; \tag{LP1} \label{eqn - lp}\</p>
<p>\mbox{s.t.}\quad</p>
<p>&amp;f_{u,v}\leqslant c_{u,v}, &amp;\quad&amp; (u,v)\in E\</p>
<p>&amp;\sum_{v} f_{uv} = \sum_v f_{vu}, &amp;{}&amp; u \in V\<br>&amp; f_{uv} \geqslant 0, &amp;{}&amp; (u,v) \in E \cup{(t,s)}</p>
<p>\end{alignat}<br>$$<br>最小割问题的线性规划描述:<br>$$<br>\begin{alignat}{2}</p>
<p>\min\quad &amp;\sum_{(u,v) \in E}c_{uv}d_{uv} &amp;{}&amp; \tag{LP2} \</p>
<p>\mbox{s.t.}\quad</p>
<p>&amp;d_{u,v}-p_u+p_v &amp;\geqslant 0, &amp;\quad&amp; (u,v)\in E\<br>&amp;p_s-p_t &amp;\geqslant 1\<br>&amp;p_u, d_{uv} \in {0, 1} </p>
<p>\end{alignat}<br>$$<br>令$p_u=[u \in S]$, $d_{uv}=\max{p_u-p_v, 0}$.</p>
<p>考虑最大流的对偶: 记由容量限制产生的变量为$d_{uv}$, 由点$u$的流量守恒产生的变量为$p_u$, 那么对偶问题就是:<br>$$<br>\begin{alignat}{2}</p>
<p>\min\quad &amp;\sum_{(u,v) \in E}c_{uv}d_{uv} &amp;{}&amp; \tag{LP3} \</p>
<p>\mbox{s.t.}\quad</p>
<p>&amp;d_{u,v}-p_u+p_v &amp;\geqslant 0, &amp;\quad&amp; (u,v)\in E\<br>&amp;p_s-p_t &amp;\geqslant 1\<br>&amp;d_{uv} &amp;\geqslant 0, &amp;{}&amp;(u,v)\in E</p>
<p>\end{alignat}<br>$$<br>我们得出结论: (最大流最小割定理)给定一个源为$s$, 汇为$t$的网络, 则$s,t$的最大流等于$s,t$的最小割.</p>
<h4 id="2-3-3-最大流算法"><a href="#2-3-3-最大流算法" class="headerlink" title="2.3.3 最大流算法"></a>2.3.3 最大流算法</h4><h5 id="2-3-3-1-Dinic算法"><a href="#2-3-3-1-Dinic算法" class="headerlink" title="2.3.3.1 Dinic算法"></a>2.3.3.1 Dinic算法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dist[maxn], iter[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(s);</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      edge &amp;e = edges[G[u][i]];</span><br><span class="line">      <span class="keyword">if</span> (e.cap &gt; <span class="number">0</span> &amp;&amp; dist[e.to] == <span class="number">-1</span>) &#123;</span><br><span class="line">        dist[e.to] = dist[u] + <span class="number">1</span>;</span><br><span class="line">        q.push(e.to);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == t)</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = iter[s]; i &lt; G[s].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    edge &amp;e = edges[G[s][i]];</span><br><span class="line">    <span class="keyword">if</span> (e.cap &gt; <span class="number">0</span> &amp;&amp; dist[e.to] &gt; dist[s]) &#123;</span><br><span class="line">      <span class="keyword">int</span> d = dfs(e.to, t, <span class="built_in">min</span>(e.cap, flow));</span><br><span class="line">      <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        e.cap -= d;</span><br><span class="line">        edges[G[s][i] ^ <span class="number">1</span>].cap += d;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    bfs(s);</span><br><span class="line">    <span class="keyword">if</span> (dist[t] == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="built_in">memset</span>(iter, <span class="number">0</span>, <span class="keyword">sizeof</span>(iter));</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">while</span> (d = dfs(s, t, inf))</span><br><span class="line">      flow += d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-3-2-费用流"><a href="#2-3-3-2-费用流" class="headerlink" title="2.3.3.2 费用流"></a>2.3.3.2 费用流</h5><p>泛指一种与费用相关的流算法.EK算法比较常用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(ll &amp;flow, ll &amp;cost)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    dist[i] = -inf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">  dist[s] = <span class="number">0</span>, inq[s] = <span class="number">1</span>, pre[s] = <span class="number">0</span>, fi[s] = inf;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(s);</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    inq[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      edge &amp;e = E[G[u][i]];</span><br><span class="line">      <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; dist[e.to] &lt; dist[u] + e.cost) &#123;</span><br><span class="line">        dist[e.to] = dist[u] + e.cost;</span><br><span class="line">        pre[e.to] = G[u][i];</span><br><span class="line">        fi[e.to] = <span class="built_in">min</span>(fi[u], e.cap - e.flow);</span><br><span class="line">        <span class="keyword">if</span> (!inq[e.to]) &#123;</span><br><span class="line">          q.push(e.to);</span><br><span class="line">          inq[e.to] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dist[t] &lt;= -inf)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (cost + dist[t] * fi[t] &lt; <span class="number">0</span>) &#123; </span><br><span class="line">    ll temp = cost / (-dist[t]); <span class="comment">//temp:还能够增加的流</span></span><br><span class="line">    flow += temp;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  flow += fi[t];</span><br><span class="line">  cost += dist[t] * fi[t];</span><br><span class="line">  <span class="keyword">int</span> u = t;</span><br><span class="line">  <span class="keyword">while</span> (u != s) &#123;</span><br><span class="line">    E[pre[u]].flow += fi[t];</span><br><span class="line">    E[pre[u] ^ <span class="number">1</span>].flow -= fi[t];</span><br><span class="line">    u = E[pre[u]].from;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mcmf</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  ll flow = <span class="number">0</span>;</span><br><span class="line">  ll cost = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (spfa(flow, cost))</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-4-建模方法"><a href="#2-3-4-建模方法" class="headerlink" title="2.3.4 建模方法"></a>2.3.4 建模方法</h3><h5 id="2-3-4-1-基本建模"><a href="#2-3-4-1-基本建模" class="headerlink" title="2.3.4.1 基本建模"></a>2.3.4.1 基本建模</h5><ul>
<li>多个源点和汇点(超级源点, 超级汇点)</li>
<li>无向图: 拆成两条边</li>
<li>顶点容量限制: 拆点</li>
<li>不相交的两条路径: 拆点</li>
<li>上下界网络流:<img src="http://images2015.cnblogs.com/blog/890886/201703/890886-20170319160907276-1392853298.png"></li>
<li>上下界费用流:<img src="http://images2015.cnblogs.com/blog/890886/201702/890886-20170221114022898-331956418.png"></li>
<li>图部分发生变化: 重复利用之前的结果</li>
</ul>
<ol>
<li>容量增加, 直接跑最大流</li>
<li>容量减少, 如果$f(e) \leq c(e)-1$, 那么不用动, 否则退流<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> now = cc[i].id;</span><br><span class="line">      <span class="keyword">int</span> u = now, v = now + n;</span><br><span class="line">      bfs(u);</span><br><span class="line">      <span class="keyword">if</span> (dist[v] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      rec[tot++] = now;</span><br><span class="line">      dinic(t, v);</span><br><span class="line">      dinic(u, s);</span><br><span class="line">      edges[(now - <span class="number">1</span>) * <span class="number">2</span>].cap = edges[(now - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>].cap = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>容量为负数: 适当变形</li>
<li>费用为负数的情况:</li>
</ul>
<ol>
<li>消负圈</li>
<li>通过适当的变形. 比如说, 如果每次增广所用的边数都是相同的(记做m), 那么把所有边的费用都加上常数$k$, 然后从最短路减去$mk$就得到了原图最短路的长度</li>
<li><img src="http://images2015.cnblogs.com/blog/890886/201703/890886-20170319162546573-925706265.png"></li>
</ol>
<h5 id="2-3-4-2-最大流建模"><a href="#2-3-4-2-最大流建模" class="headerlink" title="2.3.4.2 最大流建模"></a>2.3.4.2 最大流建模</h5><ul>
<li>与棋盘有关的题目可以考虑最大流</li>
</ul>
<h5 id="2-3-4-3-最小割建模"><a href="#2-3-4-3-最小割建模" class="headerlink" title="2.3.4.3 最小割建模"></a>2.3.4.3 最小割建模</h5><ul>
<li>用容量为$\infty$的边表示冲突</li>
<li>从两点关系的角度进行最小割建模</li>
</ul>
<h5 id="2-3-4-4-费用流建模"><a href="#2-3-4-4-费用流建模" class="headerlink" title="2.3.4.4 费用流建模"></a>2.3.4.4 费用流建模</h5><h5 id="2-3-4-5-流量平衡思想"><a href="#2-3-4-5-流量平衡思想" class="headerlink" title="2.3.4.5 流量平衡思想"></a>2.3.4.5 流量平衡思想</h5><h3 id="2-4二分图"><a href="#2-4二分图" class="headerlink" title="2.4二分图"></a>2.4二分图</h3><h4 id="2-4-1-基本定义与思想"><a href="#2-4-1-基本定义与思想" class="headerlink" title="2.4.1 基本定义与思想"></a>2.4.1 基本定义与思想</h4><ul>
<li>二分图, 指顶点可以分为两个不相交的几个$U$和$V$($U\ and\ V$皆为独立集), 使得在同一个集内的顶点不相邻的图.</li>
<li>无向图G为二分图$\Leftrightarrow$G至少有两个顶点, 且所有回路的长度均为偶数$\Leftrightarrow$没有奇圈</li>
<li>最大边独立集的基数等于最大独立集的基数</li>
<li>最大独立集的基数和最大匹配基数之和, 等于顶点数目.</li>
<li>对于连通的二分图: 最小顶点覆盖集的基数等于最大匹配的基数</li>
<li>Hall定理是一个用于判定二分图是否具有最大匹配的定理。<br>首先对于二分图G=(X∪Y,E)，点集被分为了XX和YY两部分。<br>是否具有最大匹配，首先一个最基本的条件就是|X|=|Y||X|=|Y|。<br>Hall定理则在此基础上给出了一个更强的条件。<br>首先对于一个点集T⊆X，定义Γ(T)Γ(T)如下：<br>Γ(T)={v∣u→v∈E,u∈T,v∈Y}<br>Γ(T)={v∣u→v∈E,u∈T,v∈Y}<br>即表示TT中所有点能够直接到达的YY中的点的集合。<br><img src="http://images2015.cnblogs.com/blog/890886/201703/890886-20170307142821172-459702442.png"><br>上图中，Γ({1,3})={4,5,6}Γ({1,3})={4,5,6}。<br>那么Hall条件则用于判断一个二分图是否存在最大匹配。Hall条件如下：<br>对于任意的点集T⊆X，均存在：<br>|T|≤|Γ(T)|<br>|T|≤|Γ(T)|<br>那么此二分图必定存在最大匹配。</li>
</ul>
<h4 id="2-4-2-匈牙利算法与KM算法"><a href="#2-4-2-匈牙利算法与KM算法" class="headerlink" title="2.4.2 匈牙利算法与KM算法."></a>2.4.2 匈牙利算法与KM算法.</h4><h3 id="2-5-其他常用结论"><a href="#2-5-其他常用结论" class="headerlink" title="2.5 其他常用结论"></a>2.5 其他常用结论</h3><ul>
<li>对于不存在孤立点的图，|最大匹配|+|最小边覆盖| = |V|</li>
</ul>
<ul>
<li>最大独立集合 +  最小顶点覆盖 =     V    </li>
</ul>
<ul>
<li><p>对于二分图：|最大匹配| = |最小顶点覆盖|</p>
</li>
<li><p>平面圖的頂點個數、邊數和面的個數之間有一個以歐拉命名的公式：<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4931496bfad0e20365b93a0f2c8d996d3b385e0c" alt="V-E+F=C+1"></p>
<p>其中，V是頂點的数目，E是邊的數目，F是面的數目，C是组成圖形的連通部分的數目。當圖是單連通圖的時候，公式簡化為： <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/759601e482258ff7a359a7db381abf60372c5b06" alt="V-E+F=2"></p>
</li>
<li><p>任何一个平面图的对偶图仍然是平面图</p>
</li>
</ul>

      </div>
      
      
      
    </div>
    

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GRAPHIC"><span class="nav-number">1.</span> <span class="nav-text">GRAPHIC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%9B%BE%E8%AE%BA"><span class="nav-number">1.1.</span> <span class="nav-text">2.图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="nav-number">1.1.1.</span> <span class="nav-text">2.1图的连通性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">2.1.1 双连通分量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">2.1.2 强连通分量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-2-SAT"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">2.1.3 2-SAT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">1.1.2.</span> <span class="nav-text">2.2 最短路与最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-SPFA"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">2.2.1 SPFA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E5%8A%A8%E6%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">2.2.2 动态最小生成树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="nav-number">1.1.3.</span> <span class="nav-text">2.3网络流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">2.3.1 预备知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E5%AE%9A%E7%90%86%E4%B8%8E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">2.3.2 最大流最小割定理与线性规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">2.3.3 最大流算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-3-1-Dinic%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.3.3.1.</span> <span class="nav-text">2.3.3.1 Dinic算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-3-2-%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="nav-number">1.1.3.3.2.</span> <span class="nav-text">2.3.3.2 费用流</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.4.</span> <span class="nav-text">2.3.4 建模方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-4-1-%E5%9F%BA%E6%9C%AC%E5%BB%BA%E6%A8%A1"><span class="nav-number">1.1.4.0.1.</span> <span class="nav-text">2.3.4.1 基本建模</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-4-2-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%BB%BA%E6%A8%A1"><span class="nav-number">1.1.4.0.2.</span> <span class="nav-text">2.3.4.2 最大流建模</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-4-3-%E6%9C%80%E5%B0%8F%E5%89%B2%E5%BB%BA%E6%A8%A1"><span class="nav-number">1.1.4.0.3.</span> <span class="nav-text">2.3.4.3 最小割建模</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-4-4-%E8%B4%B9%E7%94%A8%E6%B5%81%E5%BB%BA%E6%A8%A1"><span class="nav-number">1.1.4.0.4.</span> <span class="nav-text">2.3.4.4 费用流建模</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-4-5-%E6%B5%81%E9%87%8F%E5%B9%B3%E8%A1%A1%E6%80%9D%E6%83%B3"><span class="nav-number">1.1.4.0.5.</span> <span class="nav-text">2.3.4.5 流量平衡思想</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">1.1.5.</span> <span class="nav-text">2.4二分图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%9D%E6%83%B3"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">2.4.1 基本定义与思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E4%B8%8EKM%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">2.4.2 匈牙利算法与KM算法.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%BB%93%E8%AE%BA"><span class="nav-number">1.1.6.</span> <span class="nav-text">2.5 其他常用结论</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chen Geng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">179</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">96</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

      
<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="250" height="250" id="resCanvas" style="width:100%">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/2-SAT/" rel="tag">2-SAT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">AC自动机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BSGS/" rel="tag">BSGS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CDQ%E5%88%86%E6%B2%BB/" rel="tag">CDQ分治</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FFT/" rel="tag">FFT</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KMP/" rel="tag">KMP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Manacher/" rel="tag">Manacher</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NTT/" rel="tag">NTT</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Polya%E5%AE%9A%E7%90%86/" rel="tag">Polya定理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Prufer%E7%BC%96%E7%A0%81/" rel="tag">Prufer编码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Trie/" rel="tag">Trie</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dfs%E5%BA%8F%E5%88%97/" rel="tag">dfs序列</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lca/" rel="tag">lca</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lct/" rel="tag">lct</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spfa/" rel="tag">spfa</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/splay/" rel="tag">splay</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">上下界网络流</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/" rel="tag">主席树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%B1%E6%90%9E/" rel="tag">乱搞</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" rel="tag">二分图</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E4%BB%B7%E6%8F%90%E5%89%8D%E8%AE%A1%E7%AE%97/" rel="tag">代价提前计算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%80%8D%E5%A2%9E/" rel="tag">倍增</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%B8%E5%8C%85/" rel="tag">凸包</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%9D%97/" rel="tag">分块</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B1%82%E5%9B%BE/" rel="tag">分层图</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/" rel="tag">分数规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB/" rel="tag">动态点分治</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">单调栈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" rel="tag">单调队列</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" rel="tag">博弈论</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E6%A0%B9/" rel="tag">原根</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" rel="tag">后缀数组</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">后缀自动机</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/" rel="tag">多项式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A5%BD%E9%A2%98/" rel="tag">好题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/" rel="tag">字典序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/" rel="tag">字符串哈希</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/" rel="tag">容斥原理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B3%E9%9D%A2%E5%9B%BE/" rel="tag">平面图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%BF%E4%B9%89%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">广义后缀自动机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/" rel="tag">强连通分量</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%86%E7%82%B9/" rel="tag">拆点</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/" rel="tag">括号序列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%91%B8%E9%B1%BC/" rel="tag">摸鱼</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E4%BD%8DDP/" rel="tag">数位DP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/" rel="tag">数学知识</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">37</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/" rel="tag">斜率优化</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/" rel="tag">最大流</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/" rel="tag">最小割</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">权值线段树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">李超线段树</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%9A%E4%B8%BE/" rel="tag">枚举</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/" rel="tag">树上倍增</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E5%A5%97%E6%A0%91/" rel="tag">树套树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E5%BD%A2DP/" rel="tag">树形DP</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E5%BD%A2dp/" rel="tag">树形dp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" rel="tag">树状数组</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" rel="tag">树链剖分</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9E%8B%E8%BD%AC%E5%8C%96/" rel="tag">模型转化</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag">模板</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/" rel="tag">欧拉函数</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%82%B9%E5%88%86%E6%B2%BB/" rel="tag">点分治</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%B9%E6%AE%8A%E6%95%B0%E5%88%97/" rel="tag">特殊数列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8A%B6%E5%8E%8BDP/" rel="tag">状压DP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" rel="tag">生成函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">生成树</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0/" rel="tag">生成树计数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/" rel="tag">矩阵乘法</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/" rel="tag">矩阵树定理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/" rel="tag">离散对数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A6%BB%E7%BA%BF%E5%A4%84%E7%90%86/" rel="tag">离线处理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/" rel="tag">线性规划</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" rel="tag">组合数学</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%93%E8%AE%BA%E9%A2%98/" rel="tag">结论题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">网络流</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/" rel="tag">莫队算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%92%9F%E8%92%BB/" rel="tag">蒟蒻</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%9F%E7%8E%AF/" rel="tag">负环</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/" rel="tag">费用流</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%80%E6%B5%81/" rel="tag">退流</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/" rel="tag">高斯消元</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/" rel="tag">高精度</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BB%98%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/" rel="tag">默比乌斯反演</a><span class="tag-list-count">2</span></li></ul>
        </canvas>
    </div>
</div>


    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Geng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
